#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# このノードは navigation スタックへの操作を経路ファイルから行います
#

import time
import rospy
import json
from std_msgs.msg import String
from nav_msgs.msg import Odometry
from rosgraph_msgs.msg import Log
import itertools

def main():
    rospy.init_node('planner')
    planner = Planner()
    planner.main()

class Planner():
    def __init__(self):
        self.__path_pub = rospy.Publisher(
            "/path", String, queue_size=1)
        self.__commander_sub = rospy.Subscriber(
            "/commander/meta_info", String, self.__commander_cb, queue_size=1)
        self.__shortest_path_dict = {}
        self.__vertex_dict = {} # self.__vertex_dict: vertexのidをキーにvertexを持っている
        self.__vertex_list_param = rospy.get_param("/vertex_list")
        self.__init_graph()  # __vertex_list_param から Vertex と Edge を作成

    def main(self):
        # full_path = self.__calc_all_patterns(start_vertex_id=0)
        # for _ in range(10):
        #     self.__send_path(full_path)
        #     time.sleep(2)
        rospy.spin()

    def __commander_cb(self, data):
        payload = json.loads(data.data)
        if "is_started" in payload and payload["is_started"]:
            full_path = self.__calc_all_patterns(start_vertex_id=0)
            self.__send_path(full_path)

        # rospy.loginfo("Before Destinations: %s" % [key for key in self.__vertex_dict if self.__vertex_dict[key].get_is_destination()])
        if "is_destination" in payload and payload["is_destination"]:
            self.__vertex_dict[payload["vertex_id"]].set_is_destination_false()
        # rospy.loginfo("After Destinations: %s" % [key for key in self.__vertex_dict if self.__vertex_dict[key].get_is_destination()])
        
    def __send_path(self, full_path):
        position_full_path = []
        # vertex_id から 座標を取得しListに格納する
        for v in full_path:
            x, y = v.get_position()
            position_full_path.append(dict(
                x = x,
                y = y,
                tolerance = 0.15,
                is_destination = v.get_is_destination(),
                vertex_id=v.get_vertex_id()
            ))

        # 作成した座標データをCommander Node に送信する
        self.__path_pub.publish(json.dumps(position_full_path))


    def __init_graph(self):
        # Vertex を生成
        self.__vertex_list = []  # HACK: これは、self.__vertex_dict に置きかる
        # NOTE: __vertex_list_param のインデックスと vertex_id が一致する保証はないため
        self.__vertex_dict = {}
        for v in self.__vertex_list_param:
            if v["id"] in self.__vertex_dict:
                rospy.logwarn("[Class: %s]: vertex id:%d is already exists" % (self.__class__.__name__, v["id"]))
            vertex = Vertex(v["id"], v["x"], v["y"], v["is_destination"])
            self.__vertex_list.append(vertex)
            self.__vertex_dict[v["id"]] = vertex
        self.__destination_num = len([x for x in self.__vertex_list if x.get_is_destination()])
        # Vertex を Edge で繋ぐ
        FLAG_STR = "%d-%d"
        linked_vertex_flag = dict()
        edge_counter = 0
        for v in self.__vertex_list_param:
            for lv in v["linked_vertex_list"]:
                key = FLAG_STR % (v["id"], lv)
                if key in linked_vertex_flag:
                    continue
                # NOTE: __vertex_list_param のインデックスと vertex_id が一致する保証はないため
                #       vertex_id　から当該 Vertex を確実に取得できる self.__vertex_dict を利用する
                Edge(self.__vertex_dict[v["id"]], self.__vertex_dict[lv])
                linked_vertex_flag[key] = True
                key = FLAG_STR % (lv, v["id"])
                linked_vertex_flag[key] = True
                edge_counter += 1

    def __calc_all_patterns(self, start_vertex_id=0):
        destination_id_list = []
        start_vertex = None
        # 目的地となるvertex_idを取得する
        for vertex in self.__vertex_list:
            if vertex.get_is_destination():
                self.__dijkstra_planner(vertex)
                vertex_id = vertex.get_vertex_id()
                if vertex_id != start_vertex_id:
                    destination_id_list.append(vertex_id)
                else:
                    start_vertex = vertex
        # すべての巡回経路を算出
        all_patterns = map(list, itertools.permutations(destination_id_list))
        mini_cost = float("inf")
        mini_cost_path = None
        # 最小となる巡回経路を算出する
        for path in all_patterns:
            p = start_vertex_id
            tmp_cost = 0
            for c in path:
                key = "%d-%d" % (p, c)
                p = c
                tmp_cost += self.__shortest_path_dict[key]["cost"]
            if mini_cost > tmp_cost:
                mini_cost = tmp_cost
                mini_cost_path = path

        p = start_vertex_id
        full_path = [start_vertex]
        for c in mini_cost_path:
            key = "%d-%d" % (p, c)
            p = c
            half_path = self.__shortest_path_dict[key]["path"]
            if half_path[0].get_vertex_id() == c:
                half_path.reverse()
            full_path.extend(half_path[1:])
        rospy.loginfo("Destination path: %s" % mini_cost_path)
        rospy.loginfo("Full path: %s" % map(lambda x: x.get_vertex_id(), full_path))
        return full_path

    def __dijkstra_planner(self, start_vertex):

        # vertexごとのSTARTからの最小コスト
        min_dist_dict = {}
        min_dist_dict[start_vertex] = 0
        # vertexに最小コストで辿り着く場合の直前のノード
        prev_vertex_dict = {}
        prev_vertex_dict[start_vertex] = Vertex(None, None, None)
        queue = []
        # START vertex をキューにプッシュ
        queue.append(start_vertex)
        arrived_destination = []
        arrived_destination.append(start_vertex)

        while True:
            # 確定した vertex から遷移可能な vertex のうち
            # 最小コストと遷移先ノードを min_dist_dict と prev_node_dict に設定
            queue.sort(key=lambda v: min_dist_dict[v])
            vertex = queue.pop(0)

            # GOAL
            if vertex.get_is_destination():
                # goalノードには複数回行くことがあるのでリストとか作ってlength使う?
                if not vertex in arrived_destination:
                    path = []
                    tmp_vertex = vertex
                    while True:
                        path.append(tmp_vertex)
                        if tmp_vertex.get_vertex_id() == start_vertex.get_vertex_id():
                            break
                        tmp_vertex = prev_vertex_dict[tmp_vertex]
                    result = {
                        "cost": min_dist_dict[vertex],
                        "path": path
                    }
                    key = "%d-%d" % (path[0].get_vertex_id(), path[-1].get_vertex_id())
                    self.__shortest_path_dict[key] = result
                    key = "%d-%d" % (path[-1].get_vertex_id(), path[0].get_vertex_id())
                    self.__shortest_path_dict[key] = result
                    arrived_destination.append(vertex)
                    if(len(arrived_destination) >= self.__destination_num):
                        return

            prev_vertex = vertex
            # 確定したノードから遷移可能な vertex について
            # コストを計算し、キューに追加する
        
            # 直前に確定した vertex から遷移可能な edge について繰り返し
            for arrival_edge in prev_vertex.get_edge_list():
                # 遷移可能なvertexについて、直前に確定したvertexから遷移した場合のコストを計算
                tmp_d = min_dist_dict[prev_vertex] + arrival_edge.get_cost()
                arrival_vertex = arrival_edge.get_opposite_vertex(prev_vertex)
                # 過去に遷移先ノードの最小コストを計算済みかどうか
                if arrival_vertex in min_dist_dict.keys():
                    # 過去に計算していたSTARTからの最小コストより直前に確定したノードから遷移した場合の
			        # コストが小さかった場合，最小コストを更新
                    if tmp_d < min_dist_dict[arrival_vertex]:
                        min_dist_dict[arrival_vertex] = tmp_d
                        queue.append(arrival_vertex)
                        prev_vertex_dict[arrival_vertex] = prev_vertex
                else:
                    min_dist_dict[arrival_vertex] = tmp_d
                    queue.append(arrival_vertex)
                    prev_vertex_dict[arrival_vertex] = prev_vertex

class Vertex:
    def __init__(self, vertex_id, x, y, is_destination=False):
        self.__edge_list = []  # 
        self.__x = x
        self.__y = y
        self.__is_destination = is_destination
        self.__vertex_id = vertex_id
    
    def set_edge(self, edge):
        if edge in self.__edge_list:
            return
        self.__edge_list.append(edge)

    def remove_edge(self, edge):
        if not edge in self.__edge_list:
            return
        self.__edge_list.remove(edge)

    def get_position(self):
        return self.__x, self.__y

    def get_is_destination(self):
        return self.__is_destination
    
    def get_edge_list(self):
        return self.__edge_list
    
    def get_vertex_id(self):
        return self.__vertex_id

    def set_is_destination_false(self):
        self.__is_destination = False


class Edge:
    def __init__(self, vertex_a, vertex_b):
        self.__vertex_list = [vertex_a, vertex_b]
        self.__cost = self.__calc_cost()
        vertex_a.set_edge(self)
        vertex_b.set_edge(self)

    def get_opposite_vertex(self, my_vertex):
        if not my_vertex in self.__vertex_list:
            return None
        for v in self.__vertex_list:
            if v is my_vertex:
                continue
            return v

    def __calc_cost(self):
        ax, ay = self.__vertex_list[0].get_position()
        bx, by = self.__vertex_list[1].get_position()
        return ((ax - bx)**2 + (ay - by)**2)**0.5

    def get_cost(self):
        return self.__cost


if __name__ == '__main__':
    main()